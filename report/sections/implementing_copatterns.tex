%!TEX root = ../main.tex
\section{Implementing Copatterns}
\label{sec:implementing-copatterns}
%Description of our language.
%Explains the interesting details of implementing copatterns.
To explore the implementation of copatterns we have made a small toy language called \textit{findus} implemented in Haskell. It is a functional programming language with first-order functions and simple first-order types. It has the following features:

\begin{itemize}
\item Inductive Types
\item Coinductive Types
\item Let bindings
\item Pattern Matching 
\item Copatterns
\end{itemize}

Both inductive and coinductive types are implemented as iso-recursive types\,\cite[p. 275]{Pierce:2002:TPL:509043}. This means their implementations are very similar. The inductive types (\texttt{TRecInd} in Figure~\ref{fig:types}) are defined by the name of the type and then a variant type (\texttt{TVari}). The variant type consists of a list which defines the constructors, where the string part is the name of the constructors and the types are the types of the constructor parameters. The coinductive type (\texttt{TRecCoind}) is defined by its name and a list of observations that is similar to the variant type definition, except that there is only one type per observation. This makes sense as an observation does not take explicit parameters, so only its return type is specified. A possible extension could be to allow observations to take parameters, but we decided against this as matching on these would just be standard pattern matching and our focus of this project was copatterns. Defining coinductive date types is done with the \texttt{ECodata} expression in Figure~\ref{fig:expr}, which is defined by the name of the type and the coinductive type that defines it.

\begin{figure}
\begin{alltt}
data Type =
  \vdots
  | TVari [(String, [Type])]          // Variant Type
  | TRecInd String Type               // Inductive Type
  | TRecCoind String [(String, Type)] // Coinductive Type
  | TRecTypeVar String                // Recursive type variable
  | TGlobTypeVar String               // Global type variable
\end{alltt}
\caption{Part of the \texttt{Type} type in findus}
\label{fig:types}
\end{figure}

Dual to pattern matching we need a way to make observations on our coinductive types. For this we have the \texttt{EObserve} expression in Figure~\ref{fig:expr}. Such an expression is defined by the coinductive type that is being observed and a list of observations. These observations consist of the name of the observation followed by an expression defining that observation. This \texttt{EObserve} expression models copatterns.

\begin{figure}
\begin{alltt}
type Params = [(String, Type)]

data Expr =
  \vdots
  | EVar String                              // Variable
  | EData String Type                        // Data
  | ECodata String Type                      // Codata
  | EObserve Type [(String, Expr)]           // Observe
  | EGlobLet String Type (Maybe Params) Expr // Global Let
  \vdots
\end{alltt}
\caption{Part of the \texttt{Expr} type in findus}
\label{fig:expr}
\end{figure}

\begin{figure}
\begin{alltt}
-- Natural numbers

natBody :: Type                         -- nat constructors
natBody = TVari [
            ("Z", []),                  -- Z Constructor
            ("S", [TRecTypeVar "nat"])  -- S Constructor
          ]

natRec :: Type
natRec = TRecInd "nat" natBody          -- nat inductive type

nat :: Expr
nat = EData "nat" natRec                -- nat data definition

-- Nat Stream

natStreamBody :: [(Sym, Type)]          -- natStream observations
natStreamBody = [
                  ("head", TGlobTypeVar "nat"),     -- Head observation
                  ("tail", TRecTypeVar "natStream") -- Tail observation
                ]

natStreamRec :: Type                    -- natStream coinductive type
natStreamRec = TRecCoind "natStream" natStreamBody  

natStream :: Expr                       -- natStream codata definition
natStream = ECodata "natStream" natStreamRec  
\end{alltt}
\caption{Natural numbers and a stream of natural numbers}
\label{fig:natandstream}
\end{figure}

Now that we have a way of representing inductive and coinductive types, let us look at some examples of their use. In Figure~\ref{fig:natandstream} the abstract syntax representation of natural numbers (\texttt{nat}) and a stream of natural numbers (\texttt{natStream}) is shown. The type \texttt{TGlobTypeVar} is used for referencing globally defined type, and \texttt{TRecTypeVar} is a reference to the type currently being defined. From these we can define the stream of zeros in Figure~\ref{fig:astzeros}. We wrap \texttt{zerosExpr} in a \texttt{EGlobLet} which is a top-level let binding existing in a global scope. A such \texttt{EGlobLet} is defined by its name, its annotated type, its parameters (if any), and its body.

\begin{figure}
\begin{alltt}
zerosLet :: Expr
zerosLet = EGlobLet "zeros" (TGlobTypeVar "natStream") Nothing zerosExpr

zerosExpr :: Expr
zerosExpr = EObserve (TGlobalTypeVar "natStream") [
            ("head", EVar "Z"),
            ("tail", EVar "zeros")
        ]
\end{alltt}
\caption{A stream of zeros.}
\label{fig:astzeros}
\end{figure}

\subsection{Type checking}
$Findus$ is type checked according to the rules described by Pierce\,\cite{Pierce:2002:TPL:509043}. This means that everything is annotated, and nothing is inferred.

When type checking copatterns we know from Section~\ref{sec:copatterns} that the type of the result of performing an observation depends on the type of the observation. This means that the expression defining an observation must have the same type as the observation. In the example of \texttt{natStream}, the expression defining a \texttt{head} observation must be of type \texttt{TGlobTypeVar "nat"}. As such type checking copatterns is fairly simple, as we just need to check that the types between observation and definitions match.

\subsection{Evaluation}
Due to the nature of coinductive types they are not actually evaluated until they are observed. As oppose to the approach discussed in Section~\ref{sec:stateinidris}, with copatterns we need not rely on lazy evaluation. Looking at the \texttt{nats} example from its implementation with copatterns can be seen in Figure~\ref{fig:nats_copatterns}. Evaluating \texttt{nats} in itself does not make much sense as there is nothing to evaluate. Evaluation does not occur until we observe \texttt{nats}. When observing \texttt{nats} we simply look at the definitions and unfold them. Assuming an evaluation function $\epsilon$ we have the following examples of reductions:

\begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`_=8}]
$\epsilon$[head nats] = Z
$\epsilon$[tail nats] = map S nats
$\epsilon$[head tail nats] = $\epsilon$[head (map S nats)] = $\epsilon$[S (head nats)] = S Z
$\epsilon$[tail tail nats] = $\epsilon$[tail (map S nats)] = map S (tail nats)
\end{Verbatim}

We evaluate by unfolding until we either cannot unfold a coinductive definition anymore, or get an expression that is not coinductive. We know that a coinductive definition cannot be unfolded if it there does not exist a rewrite rule for it. There exists for example no rewrite rule for \texttt{nats} as it is defined by the observations that can be made on it, but there does exist one for \texttt{tail nats} as it is directly defined as \texttt{map S nats}. For this to work we require that this unfolding of definitions cannot cause an infinite series of unfolds, which means that coinductive definition have to be productive. Productivity will be discussed further in Section~\ref{sec:productivity}. 