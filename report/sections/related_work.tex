%!TEX root = ../main.tex
\section{Related Work}
\label{sec:related_work}
This section gives a survey of relevant literature, mostly covering approaches to ensuring termination of programs defined over both inductive and coinductive data.

\subsection{Size-change Termination}
Due to the fact that Idris already has a working totality checker using size-change termination\,\citep{BradyIdrisImpl13}, it is important that a solution for determining the productivity of cofunctions takes this principle into account. The size-change principle for termination was first proposed for a strict first-order functional language (without loop constructs) by Lee, Jones, and Ben-Amram\,\citep{LeeJones01SizeChange}. The principle essentially states that if infinitely many recursive calls to a function would lead to infinite decrease in some parameter value, then the function must be terminating, since any value of an inductive type must have a finite structure. This last condition is of particular importance, as the size-change principle cannot in general decide termination of functions whose parameters do not have a well-founded order. In the graph formulation of their algorithm, termination is decided by identifying any recursive calls (both direct and indirect) through call graph completion, and then constructing a ``size-change graph'' for each call. These are then used to determine whether infinite descent in some parameter value is present.

Since its first-order formulation, the principle has been proven to work for more expressive cases. Jones and Bohr\,\citep{Jones04Untyped} showed that size-change termination can be applied to the untyped lambda calculus using abstract interpretation. Interesting results of this work include size-change termination of programs employing the Y-combinator.

Following the work on the untyped lambda calculus, Sereni and Jones generalized the size-change principle to handle a higher-order functional language with user-defined data types and general recursion\,\citep{Sereni05terminationanalysis,Sereni06Phd}. Here, a termination criterion is presented which works for arbitrary control-flow graphs, and in turn is able to decide termination of lazy functional programs. A key point in this work is how different approaches to control-flow and call graph construction may influence the preciseness of the termination analysis.

Most implementations of the size-change principle only work on data for which some well-founded order exists. Nevertheless, Avery\,\citep{Avery06} presented a formulation in which it is possible to determine size-change termination for non-well-founded data types --- in particular, this formulation is shown to work for a language with an integer type. Instead of identifying infinite descent using a well-founded partial order on values, the analysis is based on a decrease in invariants which are found to hold for each program point. Thus, if the value of some invariant (which can involve arbitrarily many values) can be shown to decrease on every passage of a program point, then the program terminates. While an approach to size-change termination involving non-well-founded data is definitely closer to a usable definition for deciding the productivity of cofunctions with copatterns, Avery's formulation is insufficient or impractical in several aspects. First, it is still assumed that termination is determined solely on the basis of an infinitely decreasing property that is bounded from below. However, many cofunctions defined with copatterns exhibit no such property; Indeed, one of the virtues of cofunctions is exactly the ability to define infinite structures. Secondly, the formulation works on a graph of program points. Since it is valid for a cofunction to be defined in terms of itself, non-termination for copatterns only becomes apparent when observations are defined in terms of themselves (and as such, they can be said not to be defined at all, see Section \ref{sec:background}\todo{Remember this backwards reference to Section \ref{sec:background}}). Thus, constructing a graph of all observations in the system would be necessary for this approach to work, and such an undertaking might not be ideal (see Section \ref{sec:productivity}\todo{remember this forward reference to Section \ref{sec:productivity}}).

In more recent work, Hyvernat\,\citep{Hyvernat13} has proposed a formulation of the size-change principle for constructor-based functional languages which to a certain degree solves the problem of non-monotonic decrease in parameter values. The motivation behind this work is to incorporate size-change termination into the PML language\,\cite{PMLLanguage}. Almost all formulations prior to this work has the limitation that parameter values must decrease monotonically: values cannot at any point become structurally larger, even though the total change in size in a call chain would ultimately lead a to a decreasing value. Non-monotonic decrease is achieved by tracking the size of a parameter throughout the entire control-flow graph, instead of merely recording whether each call in isolation leads to a decrease in some value. As an extension, Hyvernat proposes that infinite data can be covered by the principle by counting the number of (lambda) abstractions and compare these to the number of function applications in a program. In this form, however, this proposal seems inadequate for a usable productivity checker for copatterns, since it relies directly on function abstractions. The idea of counting abstractions can be usable for copatterns in a different form, though (see Section \ref{sec:productivity}\todo{Remember this forward reference to Section 5}).

The termination criterion that comes closest to the size-change principle, and which actually predates the original size-change article (\citep{LeeJones01SizeChange}), is the \texttt{foetus} termination checker developed by Abel\,\citep{Abel98foetus}. \texttt{foetus} forms the basis of the totality checker used by Agda\,\citep{Norell:thesis}. In a similar manner, Abel identifies recursive calls through call graph completion and determines termination by tracking changes in parameter sizes. This work does not make any mention of productivity for coinductive data, however.

It seems that there exists no current formulation of the size-change principle which describes how productivity for coinductive data can be ensured in a way that is suitable for a system with copatterns. In the following, we will explore several different approaches to productivity, unrelated to the size-change principle.

\subsection{Guarded Corecursion}
The basic idea of guarded corecursion is that the productivity of cofunctions can be ensured by a purely syntactic check. It was first proposed by Coquand\,\citep{Coquand94} as an important part of a ``guarded proof induction principle'' for a proof system containing coinductive definitions, inspired by a similar approach in the area of process calculi by Milner\,\citep{Milner82}. In continuation of Coquand's efforts, Gim\'{e}nez applied the method to the Calculus of Constructions in order to avoid the introduction of non-normalizable terms\,\citep{Gimenez95}. 

The guardedness property described by Coquand and Gim\'{e}nez was intended to be used within a proof system (e.g. Coq\,\citep{Coq:manual}) in order to prove specifications involving coinductive types, not necessarily taking a more practical programming setting into account. In such setting, Telford and Turner argue that this approach is too conservative\,\citep{Telford98ensuringthe}. Because \emph{all} recursive calls to a cofunction must appear directly under a destructor, many intuitive defintions of standard functions (e.g. \texttt{nats} in Figure \ref{fig:nats}) are not considered productive.

\begin{figure}
\begin{alltt}
                      nats : Stream Nat
                      head nats = Z
                      tail nats = map S nats
\end{alltt}
\caption{A straightforward definition of the natural numbers using copatterns. This definition would not be deemed productive by the original guardedness principle.}
\label{fig:nats}
\end{figure}

In their ESFP system\,\citep{Telford97ensuringstreams,Telford98ensuringthe}, Telford and Turner extend the principle to accept a wider range of cofunctions as being productive, showing it to be usable in a realistic programming setting. They achieve this by considering guardedness more abstractly over a domain of guardedness levels, such that productive corecursion is bounded by a given ``depth''. As an advanced example, they show that the Hamming function is considered productive within their system. A variant of this idea will be discussed in relation to copatterns in Section \ref{sec:productivity}\todo{Remember this forward reference to Section \ref{sec:productivity}}.

Another approach to coping with the conservative nature of the original guardedness principle is to consider alternative programming styles, making productive definitions easier to write. Following the incorporation of the guardedness condition into the Agda termination checker\,\citep{AltenkirchNAD10}, Danielsson\,\citep{Danielsson10beatingthe} described a method for working around the productivity checker whenever a productive program is rejected as non-terminating. Essentially, he designs an embedded domain specific language, implements the rejected program in said language, and then provides an interpreter which is accepted by the guardedness condition. Although useful, Danielsson argues that efficiency is a concern, and that the best solution might be to entirely move away from using guardedness for productivity (for Agda, the idea of sized types have since been implemented).

In recent work, Atkey and McBride\,\citep{AtkeyMcBride13} have developed an exprimental calculus with coinductive types in which productive programs can be typed by introducing ``clock variables'' to the type system. The idea is to move the guardedness check from the syntactic level to the type level, by using \emph{guardedness type constructors} to represent values which can only be used in a guarded manner. These type constructors are then annotated by clock variables, such that it is possible for them to model guarded values which may only be available ``tomorrow''. The input and output of a function can then be typed such that they run on the same or related clocks, expressing certain guarantees about how many observations one can make on a given value. This idea of time will be revisited in Section \ref{sec:productivity}\todo{Remember this reference to Section \ref{sec:productivity}}. Although Atkey and McBride's approach seems to strike a fine balance between a syntactic guardedness check and full-blown sized types, it does at this point require a certain style of programming which looks quite inflexible, making the approach less ideal for programming with copatterns.


\subsection{Sized Types}
The idea of sized types is that instead of determining termination using a syntactic check, such as it is the case for guarded corecursion, size information is added to the type system. This enables the user to write programs with stronger specifications (in terms of types), such that only  arguments of a certain size are accepted or that the size of the output is guaranteed to be bounded by some size. The term ``size'' is used quite broadly here, without implying any specific structure of the data. Note that unlike the size-change principle or guarded corecursion, approaches using sized types for termination checking both inductive and coinductive data within the same system have been presented.

Sized types for termination checking were first proposed by Hughes, Pareto, and Sabry\,\citep{Hughes96} for reactive systems, where each data type introduced into a program is associated with a family of sized types indicating their bounds. A similar idea was developed by Amadio and Coupet-Grimal\,\citep{Amadio98}, where guard conditions are introduced into the type system to ensure the productivity of coinductive data, following the work of Coquand\,\citep{Coquand94} and Gim\'{e}nez\,\citep{Gimenez95}.

Eduarde Gim\'{e}nez also presented a system for typing recursive defintions in an extension of the Calculus of Constructions using sized types\,\citep{Gimenez98structuralrecursive}. A notable result of this work is that any well-typed term in the proposed extension is normalizing with respect to lazy evalution, widening the domain of functions to which type-based termination is applicable substantially. In the wake of this extension, Abel\,\citep{Abel99terminationchecking} wrote a quite accessible paper on using sized types for termination checking of both inductive and coinductive types, showing that bidirectional type checking\,\citep{Pierce00} is suitable for a system with sized types. In particular, it is described how infinite streams can be encoded in a language as functions on natural numbers, and that the productivity of a stream can be understood in terms of its \emph{definedness}, meaning the number of times it can safely be unfolded.

The notion of definedness is also an important part of Abel and Pientka's work on applying sized types to a system with copatterns\,\citep{Abel13Wellfounded}, although here it is defined more precisely as the \emph{depth} of a value of coinductive type. By directly using the notion of depth in the type system, they show that termination of both coinductive definitions with copatterns and inductive definitions (as well as mixed inductive-coinductive) can be decided by well-founded induction on sizes within the type system. The method is shown to work for System F\textsubscript{$\omega$}, and has later been implemented in Agda along with copatterns. As such, sized types are definitely a candidate for deciding productivity of cofunctions with copatterns in Idris. However, due to various concerns discussed in Section \ref{sec:productivity}\todo{Remember this forward reference to Section \ref{sec:productivity}}, sized types may not be a desirable solution.

In relation to other methods for termination checking, Thibodeau\,\citep{Thibodeau11} presented an interesting comparison between sized types and termination checking by structural size change (such as the methods used for the size-change principle and the \texttt{foetus} termination checker). Here, Thibodeau concludes that sized types in general should be preferred over approaches examining structure, since they generally are more flexible. The main concern regarding sized types is that size annotations make the code harder to read, and seems unnecessary from the point of view of the user. It is expected, however, that it would be possible to reconstruct most size annotations automatically in a mature system. To our knowledge, it has yet to be investigated whether all size annotations could potentially be reconstructed, essentially making the user oblivious to the use of sized types.

