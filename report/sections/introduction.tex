%!TEX root = ../main.tex
\section{Introduction}
\label{sec:introduction}
%Copatterns. This is an preparatory study for our master's thesis.
%How do we fit copatterns into Idris?

In the world of functional programming, the use of inductive data types for data modeling has long been a standard practice. Inductive data types enable users to model fundamental data structures such as lists, trees, and graphs, and to analyze such data by pattern matching. Common to all inductively defined data is that it is inherently finite. Since it is defined in terms of constructors, infinite structures cannot be defined inductively in systems with finite memory unless certain evaluation strategies are abandoned. In particular, programming languages such as Haskell has successfully been able to blur the lines between finite and infinite structures by leveraging the power of lazy evaluation. Nevertheless, a more elegant approach to modeling infinite data is by the use of \emph{co}inductive data types. These were first implemented by Hagino for his SymML language\,\citep{Hagino89}, allowing users to define coinductive data in terms of its \emph{destructors}. This means that it does not make sense to think of coinductive data as something that is constructed. Rather, we think of coinductive data as something we can observe, in the sense that we can observe the values of the destructors at any given time. Coinductive data types have since been added to several other programming systems, examples of which are the Coq proof system\,\citep{Coq:manual}, Agda\,\citep{Norell:thesis}, and Idris\,\citep{BradyIdrisImpl13}.

While most (if not all) systems with inductive data types have a pattern matching construct for analyzing data, many systems with coinductive data types do not have dedicated constructs for manipulating destructors. Instead, coinductive data is also subjected to pattern matching. In SymML, Hagino describes a \texttt{merge} construct for describing the values of the destructors in a given coinductive definition. In Coq, no such construct exists, and the same is the case for Idris. In the wake of work done by Abel and Pientka\,\citep{Abel13Wellfounded} and Abel, Pientka, Thibodeau, and Setzer\,\citep{Abel13Copatterns}, a construct similar to Hagino's \texttt{merge} has recently been implemented in Agda. This construct is called a \emph{copattern}. By allowing projections on the left-hand side of function definitions, copatterns enable users to define corecursive functions in terms of observations (used interchangeably with ``destructors''). In effect, coinductive data no longer has to be analyzed with pattern matching, but can more naturally be expressed by the observations we can make on it. 

\subsection{Goals and Contributions}
This project serves as a preparation for our master's thesis, where we plan to implement copatterns and coinductive data defined by observations in Idris. Therefore, the goals of this project are:

\begin{itemize}
\item To understand the ideas behind copatterns.
\item To understand how copatterns are used in practice, for example by studying Agda.
\item To understand how copatterns can be implemented.
\item To implement a simple functional programming language with copatterns.
\item To understand how the current termination checker in Idris works by implementing a similar termination checker employing the size-change principle\,\citep{LeeJones01SizeChange} for said language.
\end{itemize}

As a result of pursuing these goals, our contributions are:

\begin{itemize}
\item An investigation into whether the intended changes can be implemented in Idris without changing its core type theory.
\item A survey of the literature describing different implementations of the size-change principle. This is done in order to find out whether it is feasible to extend the size-change termination checker in Idris to work as a productivity checker for corecursive function definitions with copatterns.
\item A proposal for a productivity checking algorithm for corecursive function definitions with copatterns.
\end{itemize} 

\subsection{Outline}
In Section~\ref{sec:background}, we describe the core concepts behind coinductive data, copatterns, and productivity. Section~\ref{sec:related_work} provides a survey of the relevant literature, in particular with respect to termination and productivity checking. The implementation of a small functional language with copatterns is described in Section~\ref{sec:implementing-copatterns}. In Section~\ref{sec:productivity}, we present our proposal for a productivity algorithm for corecursive functions with copatterns, while also discussing the virtues of other approaches to productivity checking. Section~\ref{sec:copatterns_in_idris} explains the necessary changes in order for us to add definitions with copatterns to Idris, and finally, Section~\ref{sec:conclusion} provides a conclusion on the entire project.
