%!TEX root = ../main.tex
\section{Conclusion}
\label{sec:conclusion}
Throughout this project, our main objective has been to prepare ourselves for for our coming master's thesis, where we plan to implement coinductive data by observations and corecursive function definitions with copatterns in Idris. We have sought to achieve this by first studying the theory behind coinductive data and copatterns. In this process, we found that coinductive data is dual to inductive data, in the sense that where the latter is defined in terms of constructors, the former is most naturally defined in terms of the observations we can make on it. Copatterns provide an elegant way of defining corecursive functions by observations, and thus seem like a valuable addition to Idris. 

To understand the implementation-specific details behind copatterns, we subsequently went ahead and implemented them in a simple functional programming language. From this, we found that neither coinductive types nor copatterns proved to be complex to implement. Coinductive types can be modeled as recursive types, while copatterns be added as a language construct similar to pattern matching. Therefore, we expect that the greatest challenge ahead will not be the implementation of copatterns in itself, but rather how they can be added to the existing Idris system.

Following an investigation into the existing literature on the size-change principle, we concluded that no implementation of the principle exists which would be suitable as a productivity checking algorithm for definitions with copatterns. Of the other approaches considered, sized types seems most promising. We decided against a recommendation of sized types for ensuring productivity, however, since it would require the user to provide too many annotations. The solution proposed in Section~\ref{sec:productivity} is thus entirely a syntactic check. The basic idea of the algorithm is that the outcome of an observation at any time can only be defined in terms of observations that are already known at that time. Non-productive definitions are therefore exactly those definitions which require knowledge about ``the future''.

Concerning Idris, we expect that it will not be necessary to make any changes to the core type theory, since coinductive data defined by observations and function definitions with copatterns can be reduced to already existing constructs. The interplay between the size-change termination checker and our proposed productivity checking algorithm will be interesting, since it is possible for definitions with copatterns to be size-change terminating without being productive according to our algorithm.


